package operations.fsa.ver2_1;

import ides.api.core.Hub;
import ides.api.model.fsa.FSAEvent;
import ides.api.model.fsa.FSAModel;
import ides.api.plugin.model.DESEventSet;
import ides.api.plugin.model.ModelManager;
import ides.api.plugin.operation.CheckingToolbox;
import ides.api.plugin.operation.Operation;
import ides.api.plugin.operation.OperationManager;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * Checks to see whether a given language is normal with respect to another. See
 * Introduction to Discrete Event Systems by Christos G. Cassandras and Stephane
 * Lafortune 2nd Edition p. 195
 * 
 * @author Valerie Sugarman
 */
public class Normal implements Operation
{

	private LinkedList<String> warnings = new LinkedList<String>();

	private String resultMessage;

	public String getDescription()
	{
		return "Determines if the sublanguage is normal with respect to "
				+ "the plant. The plant will be prefix-closed with respect to "
				+ "the language generated by the automaton for use in"
				+ " the operation if it is not already. The unobservable event set comes from the plant.";
	}

	public String[] getDescriptionOfInputs()
	{
		return new String[] { "Plant", "Sublanguage" };
	}

	public String[] getDescriptionOfOutputs()
	{
		return new String[] { resultMessage };
	}

	public String getName()
	{
		return "normal";
	}

	public int getNumberOfInputs()
	{
		return 2;
	}

	public int getNumberOfOutputs()
	{
		return 1;
	}

	public Class<?>[] getTypeOfInputs()
	{
		return new Class<?>[] { FSAModel.class, FSAModel.class };
	}

	public Class<?>[] getTypeOfOutputs()
	{
		return new Class<?>[] { Boolean.class };
	}

	public List<String> getWarnings()
	{
		return warnings;
	}

	/**
	 * Determines whether a given language is normal with respect to a plant.
	 */
	public Object[] perform(Object[] arg0)
	{
		
		warnings.clear();
		FSAModel plant;
		FSAModel sublanguage;
		boolean isNormal;

		if (arg0.length >= 2)
		{
			if (arg0[0] instanceof FSAModel && arg0[1] instanceof FSAModel)
			{
				plant = ((FSAModel)arg0[0]);
				sublanguage = ((FSAModel)arg0[1]);
			}
			else
			{
				warnings.add(CheckingToolbox.ILLEGAL_ARGUMENT);
				return new Object[] { new Boolean(false) };
			}
		}
		else
		{
			warnings.add(CheckingToolbox.ILLEGAL_NUMBER_OF_ARGUMENTS);
			return new Object[] { new Boolean(false) };
		}

		// don't want epsilon transitions, and want determinized for subset
		// later.
		if (!CheckingToolbox.isDeterministic(plant))
		{
			plant = (FSAModel)OperationManager
					.instance().getOperation("determinize")
					.perform(new Object[] { plant })[0];
			warnings.addAll(OperationManager
					.instance().getOperation("determinize").getWarnings());
		}
		if (!CheckingToolbox.isDeterministic(sublanguage))
		{
			sublanguage = (FSAModel)OperationManager
					.instance().getOperation("determinize")
					.perform(new Object[] { sublanguage })[0];
			warnings.addAll(OperationManager
					.instance().getOperation("determinize").getWarnings());
		}

		// check to make sure that events that are in both plant and sublanguage
		// have the same observable/controllable status.
		boolean eventError = false;
		eventErrorSearch: for (Iterator<FSAEvent> i = plant.getEventIterator(); i
				.hasNext();)
		{
			FSAEvent p = i.next();
			for (Iterator<FSAEvent> j = sublanguage.getEventIterator(); j
					.hasNext();)
			{
				FSAEvent s = j.next();
				if (p.equals(s))
				{
					if (p.isControllable() != s.isControllable()
							|| p.isObservable() != s.isObservable())
					{
						eventError = true;
						// once one error is found, may as well stop searching.
						break eventErrorSearch;
					}
				}
			}
		}
		if (eventError)
		{
			warnings.add(Hub.string("errorControlObserve"));
			return new Object[] { new Boolean(false) };
		}

		// Double check that sublanguage is in fact a sublanguage of the
		// plant. (don't call the operation since that will run determinize
		// again)
		boolean isSublanguage = Subset.subset(sublanguage, plant);

		if (!isSublanguage)
		{
			warnings.add(Hub.string("errorNotSublanguage"));
			return new Object[] { new Boolean(false) };
		}

		// Done checking, start the actual operation here.
		DESEventSet unobservableEvents = ModelManager
				.instance().createEmptyEventSet();

		for (Iterator<FSAEvent> i = plant.getEventIterator(); i.hasNext();)
		{
			FSAEvent e = i.next();
			if (!e.isObservable())
			{
				unobservableEvents.add(e);
			}
		}

		// prefix-close the plant.
		FSAModel m = (FSAModel)OperationManager
				.instance().getOperation("prefixclose")
				.perform(new Object[] { plant })[0];
		warnings.addAll(OperationManager
				.instance().getOperation("prefixclose").getWarnings());

		//find prefix-closure of k
		FSAModel kBar = (FSAModel)OperationManager
				.instance().getOperation("prefixclose")
				.perform(new Object[] { sublanguage })[0];
		warnings.addAll(OperationManager
				.instance().getOperation("prefixclose").getWarnings());

		// find the natural projection of kBar
		FSAModel projkBar = (FSAModel)OperationManager
				.instance().getOperation("observer")
				.perform(new Object[] { kBar })[0];
		warnings.addAll(OperationManager
				.instance().getOperation("observer").getWarnings());

		// find the inverse of the previously determined natural project of kBar
		FSAModel invprojkBar = (FSAModel)OperationManager
				.instance().getOperation("selfloop").perform(new Object[] {
						projkBar, unobservableEvents })[0];
		warnings.addAll(OperationManager
				.instance().getOperation("selfloop").getWarnings());

		FSAModel intersection = (FSAModel)OperationManager
				.instance().getOperation("product").perform(new Object[] {
						invprojkBar, m })[0];
		warnings.addAll(OperationManager
				.instance().getOperation("product").getWarnings());

		isNormal = Subset.subset(intersection, kBar);

		if (isNormal)
		{
			resultMessage = "Sublanguage is normal with respect to the plant.";
		}
		else
		{
			resultMessage = "Sublanguage is NOT normal with respect to the plant.";
		}
		return new Object[] { new Boolean(isNormal) };

	}

}
